// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: feeds.sql

package repository

import (
	"context"
	"time"

	"github.com/google/uuid"
	gofeed "github.com/mmcdole/gofeed"
	typeext "github.com/rhajizada/gazette/internal/typeext"
)

const countFeeds = `-- name: CountFeeds :one
SELECT COUNT(*) AS count
FROM feeds
`

func (q *Queries) CountFeeds(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countFeeds)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countFeedsByUserID = `-- name: CountFeedsByUserID :one
SELECT COUNT(*) AS count
FROM user_feeds
WHERE user_id = $1
`

func (q *Queries) CountFeedsByUserID(ctx context.Context, userID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countFeedsByUserID, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createFeed = `-- name: CreateFeed :one
INSERT INTO feeds
  (title, description, link, feed_link, links, updated_parsed, published_parsed,
   authors, language, image, copyright, generator,
   categories, feed_type, feed_version)
VALUES
  ($1, $2, $3, $4, $5, $6, $7,
   $8, $9, $10, $11, $12,
   $13, $14, $15)
RETURNING
  id, title, description, link, feed_link, links, updated_parsed, published_parsed,
  authors, language, image, copyright, generator,
  categories, feed_type, feed_version, created_at, last_updated_at
`

type CreateFeedParams struct {
	Title           *string         `json:"title"`
	Description     *string         `json:"description"`
	Link            *string         `json:"link"`
	FeedLink        string          `json:"feedLink"`
	Links           []string        `json:"links"`
	UpdatedParsed   *time.Time      `json:"updatedParsed"`
	PublishedParsed *time.Time      `json:"publishedParsed"`
	Authors         typeext.Authors `json:"authors"`
	Language        *string         `json:"language"`
	Image           *gofeed.Image   `json:"image"`
	Copyright       *string         `json:"copyright"`
	Generator       *string         `json:"generator"`
	Categories      []string        `json:"categories"`
	FeedType        *string         `json:"feedType"`
	FeedVersion     *string         `json:"feedVersion"`
}

func (q *Queries) CreateFeed(ctx context.Context, arg CreateFeedParams) (Feed, error) {
	row := q.db.QueryRow(ctx, createFeed,
		arg.Title,
		arg.Description,
		arg.Link,
		arg.FeedLink,
		arg.Links,
		arg.UpdatedParsed,
		arg.PublishedParsed,
		arg.Authors,
		arg.Language,
		arg.Image,
		arg.Copyright,
		arg.Generator,
		arg.Categories,
		arg.FeedType,
		arg.FeedVersion,
	)
	var i Feed
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Link,
		&i.FeedLink,
		&i.Links,
		&i.UpdatedParsed,
		&i.PublishedParsed,
		&i.Authors,
		&i.Language,
		&i.Image,
		&i.Copyright,
		&i.Generator,
		&i.Categories,
		&i.FeedType,
		&i.FeedVersion,
		&i.CreatedAt,
		&i.LastUpdatedAt,
	)
	return i, err
}

const deleteFeedByID = `-- name: DeleteFeedByID :exec
DELETE FROM feeds WHERE id = $1
`

func (q *Queries) DeleteFeedByID(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteFeedByID, id)
	return err
}

const exportFeedsByUserID = `-- name: ExportFeedsByUserID :many
SELECT
  f.feed_link
FROM feeds f
LEFT JOIN user_feeds uf
  ON uf.feed_id = f.id
  AND uf.user_id = $1
WHERE
  (NOT $2) OR (uf.user_id IS NOT NULL)
ORDER BY f.created_at DESC
`

type ExportFeedsByUserIDParams struct {
	UserID  uuid.UUID   `json:"userId"`
	Column2 interface{} `json:"column2"`
}

func (q *Queries) ExportFeedsByUserID(ctx context.Context, arg ExportFeedsByUserIDParams) ([]string, error) {
	rows, err := q.db.Query(ctx, exportFeedsByUserID, arg.UserID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var feed_link string
		if err := rows.Scan(&feed_link); err != nil {
			return nil, err
		}
		items = append(items, feed_link)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFeedByFeedLink = `-- name: GetFeedByFeedLink :one
SELECT
  id, title, description, link, feed_link, links, updated_parsed, published_parsed,
  authors, language, image, copyright, generator,
  categories, feed_type, feed_version, created_at, last_updated_at
FROM feeds
WHERE feed_link = $1
`

func (q *Queries) GetFeedByFeedLink(ctx context.Context, feedLink string) (Feed, error) {
	row := q.db.QueryRow(ctx, getFeedByFeedLink, feedLink)
	var i Feed
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Link,
		&i.FeedLink,
		&i.Links,
		&i.UpdatedParsed,
		&i.PublishedParsed,
		&i.Authors,
		&i.Language,
		&i.Image,
		&i.Copyright,
		&i.Generator,
		&i.Categories,
		&i.FeedType,
		&i.FeedVersion,
		&i.CreatedAt,
		&i.LastUpdatedAt,
	)
	return i, err
}

const getFeedByID = `-- name: GetFeedByID :one
SELECT
  id, title, description, link, feed_link, links, updated_parsed, published_parsed,
  authors, language, image, copyright, generator,
  categories, feed_type, feed_version, created_at, last_updated_at
FROM feeds
WHERE id = $1
`

func (q *Queries) GetFeedByID(ctx context.Context, id uuid.UUID) (Feed, error) {
	row := q.db.QueryRow(ctx, getFeedByID, id)
	var i Feed
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Link,
		&i.FeedLink,
		&i.Links,
		&i.UpdatedParsed,
		&i.PublishedParsed,
		&i.Authors,
		&i.Language,
		&i.Image,
		&i.Copyright,
		&i.Generator,
		&i.Categories,
		&i.FeedType,
		&i.FeedVersion,
		&i.CreatedAt,
		&i.LastUpdatedAt,
	)
	return i, err
}

const getUserFeedByID = `-- name: GetUserFeedByID :one
SELECT
  f.id, f.title, f.description, f.link, f.feed_link, f.links,
  f.updated_parsed, f.published_parsed,
  f.authors, f.language, f.image, f.copyright, f.generator,
  f.categories, f.feed_type, f.feed_version,
  f.created_at, f.last_updated_at,
  uf.subscribed_at
FROM feeds f
JOIN user_feeds uf ON uf.feed_id = f.id
WHERE uf.user_id = $1
  AND f.id      = $2
`

type GetUserFeedByIDParams struct {
	UserID uuid.UUID `json:"userId"`
	ID     uuid.UUID `json:"id"`
}

type GetUserFeedByIDRow struct {
	ID              uuid.UUID       `json:"id"`
	Title           *string         `json:"title"`
	Description     *string         `json:"description"`
	Link            *string         `json:"link"`
	FeedLink        string          `json:"feedLink"`
	Links           []string        `json:"links"`
	UpdatedParsed   *time.Time      `json:"updatedParsed"`
	PublishedParsed *time.Time      `json:"publishedParsed"`
	Authors         typeext.Authors `json:"authors"`
	Language        *string         `json:"language"`
	Image           *gofeed.Image   `json:"image"`
	Copyright       *string         `json:"copyright"`
	Generator       *string         `json:"generator"`
	Categories      []string        `json:"categories"`
	FeedType        *string         `json:"feedType"`
	FeedVersion     *string         `json:"feedVersion"`
	CreatedAt       time.Time       `json:"createdAt"`
	LastUpdatedAt   time.Time       `json:"lastUpdatedAt"`
	SubscribedAt    time.Time       `json:"subscribedAt"`
}

func (q *Queries) GetUserFeedByID(ctx context.Context, arg GetUserFeedByIDParams) (GetUserFeedByIDRow, error) {
	row := q.db.QueryRow(ctx, getUserFeedByID, arg.UserID, arg.ID)
	var i GetUserFeedByIDRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Link,
		&i.FeedLink,
		&i.Links,
		&i.UpdatedParsed,
		&i.PublishedParsed,
		&i.Authors,
		&i.Language,
		&i.Image,
		&i.Copyright,
		&i.Generator,
		&i.Categories,
		&i.FeedType,
		&i.FeedVersion,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.SubscribedAt,
	)
	return i, err
}

const listFeeds = `-- name: ListFeeds :many
SELECT
  id, title, description, link, feed_link, links, updated_parsed, published_parsed,
  authors, language, image, copyright, generator,
  categories, feed_type, feed_version, created_at, last_updated_at
FROM feeds
ORDER BY created_at DESC
LIMIT  $1
OFFSET $2
`

type ListFeedsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListFeeds(ctx context.Context, arg ListFeedsParams) ([]Feed, error) {
	rows, err := q.db.Query(ctx, listFeeds, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Feed
	for rows.Next() {
		var i Feed
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Link,
			&i.FeedLink,
			&i.Links,
			&i.UpdatedParsed,
			&i.PublishedParsed,
			&i.Authors,
			&i.Language,
			&i.Image,
			&i.Copyright,
			&i.Generator,
			&i.Categories,
			&i.FeedType,
			&i.FeedVersion,
			&i.CreatedAt,
			&i.LastUpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFeedsByUserID = `-- name: ListFeedsByUserID :many
SELECT
  f.id, f.title, f.description, f.link, f.feed_link, f.links,
  f.updated_parsed, f.published_parsed,
  f.authors, f.language, f.image, f.copyright, f.generator,
  f.categories, f.feed_type, f.feed_version,
  f.created_at, f.last_updated_at,
  uf.subscribed_at
FROM feeds f
LEFT JOIN user_feeds uf
  ON uf.feed_id = f.id
  AND uf.user_id = $1
WHERE
  -- if subscribed_only = false, return all;
  -- if subscribed_only = true, only those where uf.user_id IS NOT NULL
  (NOT $2) OR (uf.user_id IS NOT NULL)
ORDER BY f.created_at DESC
LIMIT  $3
OFFSET $4
`

type ListFeedsByUserIDParams struct {
	UserID  uuid.UUID   `json:"userId"`
	Column2 interface{} `json:"column2"`
	Limit   int32       `json:"limit"`
	Offset  int32       `json:"offset"`
}

type ListFeedsByUserIDRow struct {
	ID              uuid.UUID       `json:"id"`
	Title           *string         `json:"title"`
	Description     *string         `json:"description"`
	Link            *string         `json:"link"`
	FeedLink        string          `json:"feedLink"`
	Links           []string        `json:"links"`
	UpdatedParsed   *time.Time      `json:"updatedParsed"`
	PublishedParsed *time.Time      `json:"publishedParsed"`
	Authors         typeext.Authors `json:"authors"`
	Language        *string         `json:"language"`
	Image           *gofeed.Image   `json:"image"`
	Copyright       *string         `json:"copyright"`
	Generator       *string         `json:"generator"`
	Categories      []string        `json:"categories"`
	FeedType        *string         `json:"feedType"`
	FeedVersion     *string         `json:"feedVersion"`
	CreatedAt       time.Time       `json:"createdAt"`
	LastUpdatedAt   time.Time       `json:"lastUpdatedAt"`
	SubscribedAt    *time.Time      `json:"subscribedAt"`
}

func (q *Queries) ListFeedsByUserID(ctx context.Context, arg ListFeedsByUserIDParams) ([]ListFeedsByUserIDRow, error) {
	rows, err := q.db.Query(ctx, listFeedsByUserID,
		arg.UserID,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListFeedsByUserIDRow
	for rows.Next() {
		var i ListFeedsByUserIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Link,
			&i.FeedLink,
			&i.Links,
			&i.UpdatedParsed,
			&i.PublishedParsed,
			&i.Authors,
			&i.Language,
			&i.Image,
			&i.Copyright,
			&i.Generator,
			&i.Categories,
			&i.FeedType,
			&i.FeedVersion,
			&i.CreatedAt,
			&i.LastUpdatedAt,
			&i.SubscribedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateFeedByID = `-- name: UpdateFeedByID :one
UPDATE feeds
SET
  title           = $2,
  description     = $3,
  link            = $4,
  feed_link       = $5,
  links           = $6,
  updated_parsed  = $7,
  published_parsed= $8,
  authors         = $9,
  language        = $10,
  image           = $11,
  copyright       = $12,
  generator       = $13,
  categories      = $14,
  feed_type       = $15,
  feed_version    = $16,
  last_updated_at = now()
WHERE id = $1
RETURNING
  id, title, description, link, feed_link, links, updated_parsed, published_parsed,
  authors, language, image, copyright, generator,
  categories, feed_type, feed_version, created_at, last_updated_at
`

type UpdateFeedByIDParams struct {
	ID              uuid.UUID       `json:"id"`
	Title           *string         `json:"title"`
	Description     *string         `json:"description"`
	Link            *string         `json:"link"`
	FeedLink        string          `json:"feedLink"`
	Links           []string        `json:"links"`
	UpdatedParsed   *time.Time      `json:"updatedParsed"`
	PublishedParsed *time.Time      `json:"publishedParsed"`
	Authors         typeext.Authors `json:"authors"`
	Language        *string         `json:"language"`
	Image           *gofeed.Image   `json:"image"`
	Copyright       *string         `json:"copyright"`
	Generator       *string         `json:"generator"`
	Categories      []string        `json:"categories"`
	FeedType        *string         `json:"feedType"`
	FeedVersion     *string         `json:"feedVersion"`
}

func (q *Queries) UpdateFeedByID(ctx context.Context, arg UpdateFeedByIDParams) (Feed, error) {
	row := q.db.QueryRow(ctx, updateFeedByID,
		arg.ID,
		arg.Title,
		arg.Description,
		arg.Link,
		arg.FeedLink,
		arg.Links,
		arg.UpdatedParsed,
		arg.PublishedParsed,
		arg.Authors,
		arg.Language,
		arg.Image,
		arg.Copyright,
		arg.Generator,
		arg.Categories,
		arg.FeedType,
		arg.FeedVersion,
	)
	var i Feed
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Link,
		&i.FeedLink,
		&i.Links,
		&i.UpdatedParsed,
		&i.PublishedParsed,
		&i.Authors,
		&i.Language,
		&i.Image,
		&i.Copyright,
		&i.Generator,
		&i.Categories,
		&i.FeedType,
		&i.FeedVersion,
		&i.CreatedAt,
		&i.LastUpdatedAt,
	)
	return i, err
}
